<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TOP - Global Ranking</title>
    <meta name="description" content="TOP - A Neon Stack Rhythm Game with Global Leaderboard">
    <style>
        /* === BASE STYLES === */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; user-select: none; -webkit-user-select: none;
            display: flex; justify-content: center; align-items: center;
            height: 100vh;
        }

        #game-wrapper {
            position: relative;
            background-color: #050505;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        canvas {
            display: block; outline: none; width: 100%; height: 100%;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10;
        }

        /* === SCORE & COMBO UI === */
        #score-container {
            position: absolute; 
            top: 10%; /* 점수 위치 (캔버스 높이의 10% 지점) */
            text-align: center;
        }

        #score {
            font-size: 5.4rem; 
            font-weight: 900; margin: 0; line-height: 1;
            background: linear-gradient(to bottom, #FFFF00, #FFD700);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
            transition: transform 0.1s;
        }
        
        .score-pop { animation: scorePopAnim 0.3s ease-out forwards; }

        @keyframes scorePopAnim {
            0% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
            50% { transform: scale(1.4); filter: drop-shadow(0 0 50px rgba(255, 255, 255, 1)); }
            100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
        }

        #combo-msg {
            position: absolute; top: 20%; 
            font-size: 2.5rem; font-weight: bold; color: #fff;
            opacity: 0; white-space: nowrap;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
            transform: scale(0.5);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* === INTRO & MENU SCREENS === */
        #intro-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(5px);
            display: flex; flex-direction: column; align-items: center; 
            justify-content: center; /* 수직 중앙 정렬 */
            padding-top: 0; 
            box-sizing: border-box;
            z-index: 20; pointer-events: auto; cursor: pointer; transition: opacity 0.5s;
        }
        #intro-screen h1 {
            font-size: 5rem; 
            color: #fff; margin: 0; 
            /* margin-top: 45vh; 제거하고 flexbox 중앙 정렬 사용 */
            text-shadow: 0 0 20px #fff, 0 0 40px rgba(255,255,255,0.5);
            background: none; -webkit-text-fill-color: #fff;
        }
        #intro-screen p {
            /* position absolute 제거하고 흐름에 맡김 */
            margin-top: 20px; 
            font-size: 1.2rem; color: #aaa; animation: blink 1s infinite;
            letter-spacing: 2px;
        }

        #menu-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: none; backdrop-filter: none; border: none;
            padding: 0 0 60px 0; 
            box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center; 
            justify-content: space-between; 
            pointer-events: none; transform: translateY(0);
            transition: opacity 0.3s, transform 0.3s;
        }

        #menu-screen h1 {
            font-size: 4rem;
            margin-top: 35%; /* GAME OVER 위치 */
            margin-bottom: auto; 
            text-transform: uppercase;
            font-weight: 900; letter-spacing: 5px;
            line-height: 0.8; 
            width: 80%; 
            word-break: break-word; 
            background: linear-gradient(45deg, #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
            background-size: 400% 400%; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: rainbow 10s ease infinite;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
            pointer-events: auto;
            text-align: center;
        }
        
        /* 버튼 컨테이너: 초기에는 숨김 (게임중 오작동 방지) */
        .bottom-controls { 
            display: none; 
            flex-direction: column; align-items: center;
            pointer-events: auto; margin-bottom: 20px;
        }
        .game-over-mode .bottom-controls { display: flex; } /* 게임 오버 시 표시 */

        @keyframes rainbow { 
            0% { background-position: 0% 50% }
            50% { background-position: 100% 50% }
            100% { background-position: 0% 50% }
        }

        /* === BUTTONS === */
        button {
            background: rgba(0, 0, 0, 0.5); color: rgba(255, 255, 255, 0.8);
            font-family: 'Orbitron', sans-serif; font-size: 2.5rem; font-weight: 900;
            padding: 15px 50px; border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px; cursor: pointer; box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: all 0.3s ease; text-transform: uppercase; margin-bottom: 10px;
            pointer-events: auto;
        }

        button:hover {
            color: #fff; background: rgba(255, 255, 255, 0.3);
            border-color: #fff; text-shadow: 0 0 20px #fff;
            transform: scale(1.05);
        }

        button:active { transform: scale(0.95); }

        .credit {
            font-size: 0.8rem; color: #fff; letter-spacing: 1px;
            text-transform: uppercase; text-shadow: 0 0 5px rgba(0,0,0,0.8);
            opacity: 0.8; pointer-events: auto;
        }
        .credit span { color: #fff; font-weight: bold; }
        
        /* === RANKING & MODALS === */
        #ranking-btn-toggle {
            position: absolute; top: 25px; right: 25px;
            color: rgba(255, 255, 255, 0.7); font-size: 1.2rem; font-weight: bold;
            cursor: pointer; z-index: 50; pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.3); padding: 5px 10px;
            border-radius: 5px; background: rgba(0,0,0,0.5); transition: all 0.3s;
        }
        #ranking-btn-toggle:hover { color: #0ff; border-color: #0ff; text-shadow: 0 0 10px #0ff; }

        #ranking-board {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 85%; max-width: 400px;
            background: rgba(0, 0, 0, 0.9); border: 2px solid #0ff;
            border-radius: 15px; padding: 20px; box-sizing: border-box;
            z-index: 60; pointer-events: auto; text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        #high-score-list {
            list-style: none; padding: 0; margin: 15px 0 0 0; 
            font-size: 1rem; color: #fff; text-align: left;
            width: 100%; max-height: 400px; overflow-y: auto;
        }
        
        #high-score-list li {
            padding: 10px 5px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; transition: background 0.2s;
        }
        #high-score-list li:hover { background: rgba(0, 255, 255, 0.1); }
        
        #ranking-board h2 {
            color:#0ff; font-size:1.5rem; margin: 0 0 10px 0;
            font-weight: 700; text-shadow: 0 0 10px #0ff;
        }
        
        #close-ranking-board {
            margin-top: 15px; font-size: 1rem; padding: 5px 20px;
            border: 1px solid #555; color: #aaa; background: transparent;
        }
        #close-ranking-board:hover { color: #fff; border-color: #fff; }

        .replay-hint { font-size: 0.7rem; color: #aaa; margin-top: 5px; font-style: italic; }
        
        #initialsModal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); display: flex; justify-content: center; 
            align-items: center; z-index: 99; flex-direction: column;
            font-family: 'Orbitron', sans-serif; color: #fff;
            padding: 20px; box-sizing: border-box;
        }
        #initialsModal h2 { color:#f0f; text-shadow:0 0 10px #f0f; font-size: 2rem; margin-bottom: 10px; }
        #initialsModal input {
            padding: 10px; font-size: 1.5rem; text-align:center; border:3px solid #0ff; 
            background:#111122; color:#fff; width: 80%; max-width: 300px; text-transform:uppercase; 
            margin-top: 20px; border-radius: 8px;
        }
        #initialsModal button { margin-top:30px; font-size:1.5rem; padding:15px 40px; border: 2px solid #0ff; }
        #initialsModal button:disabled { border-color: #555; color: #555; cursor: not-allowed; }

        #close-replay-btn {
            position: absolute; top: 20px; right: 20px; width: 40px; height: 40px;
            background: rgba(255, 0, 0, 0.2); border: 2px solid #ff0000; border-radius: 50%;
            color: #fff; font-size: 20px; font-weight: bold; display: flex; align-items: center; justify-content: center;
            cursor: pointer; z-index: 20; pointer-events: auto; transition: all 0.2s;
            animation: blink 1s infinite;
        }
        #close-replay-btn:hover { background: rgba(255, 0, 0, 0.5); transform: scale(1.1); }
        #replay-indicator {
            position: absolute; top: 20px; left: 20px; color: #0ff; font-size: 1rem;
            font-weight: bold; text-shadow: 0 0 10px #0ff; animation: blink 1s infinite; z-index: 20;
        }
        #loading-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #FFFF00; font-size: 0.8rem; z-index: 100;
        }

        /* === UTILITY CLASSES === */
        @keyframes blink { 50% { opacity: 0.5; } }
        .hide { opacity: 0; pointer-events: none !important; transform: translateY(20px) !important; }
        .display-none { display: none !important; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="intro-screen">
        <h1>TOP</h1>
        <p>CLICK TO START</p>
    </div>

    <div id="ui-layer">
        <div id="score-container">
            <div id="score">0</div>
        </div>
        <div id="combo-msg">PERFECT!</div>

        <div id="replay-indicator" class="display-none">REPLAY MODE</div>
        <div id="close-replay-btn" class="display-none">X</div>

        <div id="ranking-btn-toggle" class="display-none">RANKING</div>

        <div id="ranking-board">
            <h2>Worldwide Ranking</h2>
            <div class="replay-hint">Click initials to watch replay</div>
            <ul id="high-score-list">
                <li style="justify-content:center; color:#888;">Connecting...</li>
            </ul>
            <button id="close-ranking-board">CLOSE</button>
        </div>

        <div id="initialsModal" class="display-none"></div>

        <div id="menu-screen" class="hide">
            <h1>TOP</h1>
            
            <div class="bottom-controls" style="display: none;">
                <button id="start-btn">PLAY</button>
                <div class="credit">Created by <span>GoldencatWinter</span></div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="loading-indicator" class="display-none">SYNCING...</div>
</div>

<script type="module">
    // =========================================================================
    // FIREBASE & AUTH CONFIGURATION
    // =========================================================================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    const myFirebaseConfig = {
        apiKey: "AIzaSyCYEbWcIOd-h_pGylkwijzwsrlKnVjWKtA",
        authDomain: "top10-bab3c.firebaseapp.com",
        projectId: "top10-bab3c",
        storageBucket: "top10-bab3c.firebasestorage.app",
        messagingSenderId: "1058203815656",
        appId: "1:1058203815656:web:594790fd1a0d196ec6835d",
        measurementId: "G-S7EFBEHL7X"
    };

    const isCanvasEnv = typeof __firebase_config !== 'undefined';
    let firebaseConfig;

    if (isCanvasEnv) {
        firebaseConfig = JSON.parse(__firebase_config);
        console.log("Running in Canvas Mode (Internal DB)");
    } else {
        firebaseConfig = myFirebaseConfig;
        console.log("Running in Export Mode (User DB)");
    }

    let app, auth, db;
    try {
        app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
    } catch (e) {
        console.error("Firebase Init Error:", e);
    }
    
    let currentUser = null;
    const MAX_RANKING_COUNT = 30; 

    function getScoresCollection() {
        if (isCanvasEnv) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const userId = currentUser ? currentUser.uid : 'anonymous'; 
            return collection(db, 'artifacts', appId, 'users', userId, 'scores');
        } else {
            return collection(db, 'scores');
        }
    }

    async function initAuth() {
        if (!auth) return;
        try {
            if (isCanvasEnv && typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
            currentUser = auth.currentUser;
            refreshHighScores(); 
        } catch (error) {
            console.error("Auth failed:", error);
            ui.scoreList.innerHTML = '<li style="justify-content:center; color:#f00;">Connection Failed</li>';
        }
    }
    
    async function fetchTopScores() {
        if (!currentUser || !db) return [];
        try {
            const scoresCollectionRef = getScoresCollection();
            const querySnapshot = await getDocs(scoresCollectionRef);
            let docs = [];
            querySnapshot.forEach((doc) => {
                docs.push({ id: doc.id, ...doc.data() });
            });
            docs.sort((a, b) => b.score - a.score);
            return docs;
        } catch (e) {
            console.error("Fetch error:", e);
            return [];
        }
    }

    async function cleanupOldScores(allScores) {
        if (allScores.length > MAX_RANKING_COUNT) {
            const toDelete = allScores.slice(MAX_RANKING_COUNT); 
            const deletePromises = toDelete.map(s => 
                deleteDoc(doc(getScoresCollection(), s.id))
            );
            await Promise.all(deletePromises);
            return allScores.slice(0, MAX_RANKING_COUNT);
        }
        return allScores;
    }

    async function addScoreToDB(score, initials, replayData) {
        if (!currentUser || !db) return;
        ui.loading.classList.remove('display-none');
        try {
            await addDoc(getScoresCollection(), {
                score: score,
                initials: initials,
                replayData: JSON.stringify(replayData), 
                userId: currentUser.uid,
                timestamp: Date.now()
            });
            await refreshHighScores(); 
        } catch (e) {
            console.error("Save error:", e);
        } finally {
            ui.loading.classList.add('display-none');
        }
    }

    async function refreshHighScores() {
        const allScores = await fetchTopScores();
        highScores = await cleanupOldScores(allScores);
        displayHighScores();
    }

    initAuth();

    // =========================================================================
    // GAME CORE CONFIGURATION & VARIABLES
    // =========================================================================
    
    const REF_WIDTH = 1080; 
    const REF_HEIGHT = 1920; 

    const PREV_REF_WIDTH_FOR_REPLAY = 400;

    const BASE_WIDTH = REF_WIDTH / 3; 
    
    const OLD_BASE_WIDTH_REF = 322.666;
    const SIZE_RATIO_ADJUST = BASE_WIDTH / OLD_BASE_WIDTH_REF;

    const OLD_BLOCK_HEIGHT = 72;                
    const OLD_START_SPEED = 729;                
    const OLD_SPEED_INC = 12.15;                
    const OLD_PERFECT_TOL = 11;                 
    const OLD_STAR_SPEED = 72.9;                
    const OLD_GRAVITY = 4374;                   
    const OLD_DEBRIS_ROT = 24.3;                
    const OLD_PARTICLE_DECAY = 4.86;            

    const BLOCK_HEIGHT = OLD_BLOCK_HEIGHT * SIZE_RATIO_ADJUST;
    
    const START_SPEED = OLD_START_SPEED;
    const SPEED_INC = OLD_SPEED_INC;
    const PERFECT_TOL = 12.1; 
    const STAR_SPEED = OLD_STAR_SPEED;
    const GRAVITY = OLD_GRAVITY; 
    const DEBRIS_ROT = OLD_DEBRIS_ROT; 
    const PARTICLE_DECAY = OLD_PARTICLE_DECAY;

    let game_config = {
        baseWidth: 0,
        blockHeight: 0,
        startSpeed: 0,
        speedInc: 0,
        perfectTol: 0,
        starSpeed: 0,
        gravity: 0,
        debrisRot: 0,
        particleDecay: 0,
        recoveryRate: 0.10,
        shiningProb: 0.05,
        starCount: 600
    };

    let game = {
        state: 'intro', 
        blocks: [],
        debris: [],
        particles: [],
        stars: [],
        score: 0,
        combo: 0,
        cameraY: 0,
        baseHue: 0,
        current: null, 
        width: 0,
        height: 0,
        flashAlpha: 0,
        replayData: [],
        replayQueue: [],
        replayIndex: 0,
        currentSong: null,
        replayStartTime: 0, 
        replayCurrentTime: 0
    };
    let highScores = [];
    let lastTime = 0;

    // =========================================================================
    // UI ELEMENTS & HANDLERS
    // =========================================================================
    const canvas = document.getElementById('gameCanvas');
    const wrapper = document.getElementById('game-wrapper');
    const ctx = canvas.getContext('2d', { alpha: false });

    const ui = {
        score: document.getElementById('score'),
        combo: document.getElementById('combo-msg'),
        menu: document.getElementById('menu-screen'),
        btn: document.getElementById('start-btn'),
        title: document.querySelector('#menu-screen h1'),
        credit: document.querySelector('.credit'),
        scoreList: document.getElementById('high-score-list'),
        rankingBtn: document.getElementById('ranking-btn-toggle'),
        rankingBoard: document.getElementById('ranking-board'),
        closeRankingBtn: document.getElementById('close-ranking-board'),
        closeReplayBtn: document.getElementById('close-replay-btn'),
        replayIndicator: document.getElementById('replay-indicator'),
        intro: document.getElementById('intro-screen'),
        loading: document.getElementById('loading-indicator'),
        bottomControls: document.querySelector('.bottom-controls')
    };

    // =========================================================================
    // AUDIO SYSTEM
    // =========================================================================
    const SONGS = [
        { title: "Gymnopédie No.1 - Erik Satie", notes: [369.99, 440.00, 392.00, 369.99, 277.18, 246.94, 277.18, 293.66, 369.99, 440.00, 392.00, 369.99, 277.18, 246.94, 220.00, 293.66] },
        { title: "Clair de Lune - Claude Debussy", notes: [349.23, 311.13, 277.18, 261.63, 233.08, 261.63, 233.08, 207.65, 277.18, 311.13, 349.23, 415.30, 369.99, 349.23, 311.13, 277.18] },
        { title: "Gnossienne No.1 - Erik Satie", notes: [369.99, 440.00, 392.00, 369.99, 440.00, 392.00, 369.99, 293.66, 369.99, 293.66, 246.94, 293.66, 369.99, 392.00, 369.99, 392.00] },
        { title: "Träumerei - Robert Schumann", notes: [261.63, 349.23, 329.63, 349.23, 440.00, 523.25, 349.23, 440.00, 392.00, 261.63, 466.16, 440.00, 392.00, 349.23, 329.63, 293.66] },
        { title: "Salut d'Amour - Edward Elgar", notes: [329.63, 415.30, 493.88, 329.63, 554.37, 493.88, 440.00, 415.30, 369.99, 329.63, 369.99, 440.00, 415.30, 493.88, 415.30, 369.99] },
        { title: "Air on the G String - J.S. Bach", notes: [369.99, 329.63, 293.66, 277.18, 246.94, 440.00, 392.00, 369.99, 329.63, 293.66, 329.63, 369.99, 440.00, 392.00, 369.99, 329.63] },
        { title: "Nocturne Op.9 No.2 - Frédéric Chopin", notes: [466.16, 392.00, 349.23, 392.00, 311.13, 392.00, 466.16, 392.00, 349.23, 311.13, 261.63, 311.13, 349.23, 392.00, 466.16, 523.25] },
        { title: "Moonlight Sonata - L.v. Beethoven", notes: [207.65, 277.18, 329.63, 207.65, 277.18, 329.63, 207.65, 277.18, 329.63, 207.65, 277.18, 329.63, 207.65, 277.18, 329.63, 207.65] },
        { title: "The Swan - Camille Saint-Saëns", notes: [392.00, 369.99, 493.88, 440.00, 293.66, 329.63, 369.99, 392.00, 369.99, 329.63, 293.66, 246.94, 293.66, 329.63, 369.99, 392.00] },
        { title: "Liebestraum No.3 - Franz Liszt", notes: [261.63, 311.13, 415.30, 523.25, 622.25, 523.25, 415.30, 311.13, 261.63, 311.13, 415.30, 523.25, 622.25, 523.25, 415.30, 311.13] }
    ];

    const AudioSys = {
        ctx: null,
        init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        playOrgel(freq, vol = 0.3) {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(freq, t);
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(vol, t + 0.01); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + 1.8); 
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(t); osc.stop(t + 1.8);
            
            const osc2 = this.ctx.createOscillator(); const gain2 = this.ctx.createGain();
            osc2.type = 'sine'; osc2.frequency.setValueAtTime(freq * 2, t);
            gain2.gain.setValueAtTime(0, t); gain2.gain.linearRampToValueAtTime(vol * 0.15, t + 0.01);
            gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
            osc2.connect(gain2); gain2.connect(this.ctx.destination);
            osc2.start(t); osc2.stop(t + 0.6);
        },
        playStack(combo) {
            if (!game.currentSong) return;
            const notes = game.currentSong.notes; const noteIdx = (game.score) % notes.length;
            let freq = notes[noteIdx];
            const cycleLen = 16; const maxOctave = 1; 
            const cycleStep = Math.floor(game.score / cycleLen);
            let cycleIndex = cycleStep % (maxOctave * 2);
            let octaveShift = cycleIndex;
            if (cycleIndex > maxOctave) octaveShift = (maxOctave * 2) - cycleIndex;
            freq = freq * 0.5 * Math.pow(2, octaveShift);
            this.playOrgel(freq, 0.4);
            if (combo > 0) { setTimeout(() => { this.playOrgel(freq * 1.5, 0.1); }, 120); }
        },
        playFail() {
            this.playOrgel(146.83, 0.5); setTimeout(() => this.playOrgel(130.81, 0.5), 200);
        }
    };
    
    // =========================================================================
    // GAME LOGIC: SCALING & INITIALIZATION
    // =========================================================================

    function displayHighScores() {
        ui.scoreList.innerHTML = '';
        if (highScores.length === 0) {
            ui.scoreList.innerHTML = '<li style="color:#aaa; text-align:center;">No records yet.</li>';
            return;
        }
        highScores.forEach((score, index) => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span style="color:#0ff; font-weight:bold; width:30px;">${index+1}.</span> 
                <span style="color:#fff; cursor:pointer; flex-grow:1; text-align:center;" title="Click to Watch Replay">
                    ${score.initials || 'TOP'} <span style="font-size:0.8em; color:#aaa; margin-left:5px;">▶</span>
                </span> 
                <span style="font-weight:bold; color:#f0f; width:60px; text-align:right;">${score.score}</span>
            `;
            li.querySelector('span:nth-child(2)').onclick = (e) => { 
                e.stopPropagation(); 
                if(score.replayData) {
                    try {
                        const replayData = typeof score.replayData === 'string' ? JSON.parse(score.replayData) : score.replayData;
                        startReplay(replayData); 
                    } catch (error) {
                        console.error("Replay data parse error:", error);
                    }
                }
            };
            ui.scoreList.appendChild(li);
        });
    }

    function promptForInitials(newScore) {
        const existingModal = document.getElementById('initialsModal');
        if (existingModal) existingModal.remove();

        const modal = document.createElement('div');
        modal.id = 'initialsModal';
        modal.innerHTML = `<h2>NEW WORLD RECORD!</h2><p>Score: ${newScore}<br>ENTER YOUR NAME</p><input type="text" id="initialsInput" maxlength="10"><button id="submitInitials">SAVE</button>`;
        wrapper.appendChild(modal); 
        const input = document.getElementById('initialsInput');
        const btn = document.getElementById('submitInitials');
        
        const submit = async () => {
            let val = input.value.toUpperCase().trim().replace(/[^A-Z0-9 ]/g,'') || "TOP";
            if(val.length > 10) val = val.slice(0, 10);
            
            btn.innerText = "SAVING...";
            btn.disabled = true;

            await addScoreToDB(newScore, val, game.replayData);
            
            modal.remove();
        };

        input.oninput = () => {
            input.value = input.value.toUpperCase().replace(/[^A-Z0-9 ]/g, '');
        };

        btn.onclick = submit;
        input.focus();
        input.onkeydown = (e) => { if(e.key==='Enter') submit(); };
    }

    function resize() {
        const ASPECT_RATIO = REF_WIDTH / REF_HEIGHT;
        const parentW = window.innerWidth;
        const parentH = window.innerHeight;
        let w, h;

        if (parentW / parentH > ASPECT_RATIO) {
            h = parentH;
            w = h * ASPECT_RATIO;
        } else {
            w = parentW;
            h = w / ASPECT_RATIO;
        }

        const MAX_WIDTH = REF_WIDTH; 
        const MAX_HEIGHT = REF_HEIGHT;
        if (w > MAX_WIDTH) {
            w = MAX_WIDTH;
            h = MAX_HEIGHT;
        }

        wrapper.style.width = `${w}px`; 
        wrapper.style.height = `${h}px`;
        game.width = w; 
        game.height = h; 
        canvas.width = w; 
        canvas.height = h;

        const scale = w / REF_WIDTH; 

        game_config.baseWidth = BASE_WIDTH * scale;
        game_config.blockHeight = BLOCK_HEIGHT * scale;
        game_config.perfectTol = PERFECT_TOL * scale;
        
        game_config.startSpeed = START_SPEED * scale;
        game_config.speedInc = SPEED_INC * scale;
        game_config.starSpeed = STAR_SPEED * scale;
        
        game_config.gravity = GRAVITY * scale; 
        game_config.debrisRot = DEBRIS_ROT * scale; 
        game_config.particleDecay = PARTICLE_DECAY * scale; 

        initStars();
    }
    
    function initStars() {
        game.stars = [];
        for (let i = 0; i < game_config.starCount; i++) {
            const STAR_SIZE_BASE = 400; 

            game.stars.push({
                x: Math.random() * game.width, y: Math.random() * game.height,
                size: (Math.random() * 2 + 0.5) * (game.width / STAR_SIZE_BASE), 
                speed: Math.random() * game_config.starSpeed + 0.2,
                opacity: Math.random() * 0.5 + 0.3, twinkleSpeed: Math.random() * 0.05 + 0.01
            });
        }
    }

    function initGame(isDemo = false) {
        game.state = isDemo ? 'demo' : 'playing';
        game.blocks = []; game.debris = []; game.particles = []; 
        game.replayData = [];
        game.replayStartTime = performance.now();
        game.replayCurrentTime = 0;

        game.score = 0; game.combo = 0; game.cameraY = 0;
        game.baseHue = Math.floor(Math.random() * 360); game.flashAlpha = 0;
        
        if (!isDemo || !game.currentSong) { game.currentSong = SONGS[Math.floor(Math.random() * SONGS.length)]; }

        ui.score.innerText = "0"; ui.score.classList.remove('score-pop'); 
        
        if (isDemo) {
            ui.menu.classList.remove('hide');
            ui.menu.classList.remove('game-over-mode');
            ui.rankingBtn.classList.remove('display-none');
            // --- 수정: 데모 모드일 때만 PLAY 버튼 표시 ---
            ui.bottomControls.style.display = 'flex';
            ui.btn.innerText = "PLAY";
            ui.title.innerText = "TOP";
        } else {
            ui.menu.classList.add('hide');
            ui.rankingBtn.classList.add('display-none');
            ui.rankingBoard.style.display = 'none';
            // 게임 시작 시 버튼 숨김
            ui.bottomControls.style.display = 'none';
        }
        ui.replayIndicator.classList.add('display-none');
        ui.closeReplayBtn.classList.add('display-none');
        
        // --- 시작 블록 위치를 캔버스 높이의 90% 지점으로 설정 ---
        const startY = game.height * 0.90;

        const baseBlock = { x: (game.width-game_config.baseWidth)/2, y: startY, w: game_config.baseWidth, h: game_config.blockHeight, hue: game.baseHue };
        game.blocks.push(baseBlock);

        spawnBlock();
    }

    function startGame() { initGame(false); }

    function spawnBlock() {
        const prev = game.blocks[game.blocks.length-1];
        game.baseHue = (game.baseHue + 10) % 360;
        const isShining = Math.random() < game_config.shiningProb;
        
        const cycle = game.score % 60;
        const speedFactor = cycle < 30 ? cycle : (60 - cycle);
        const currentSpeed = game_config.startSpeed + (speedFactor * game_config.speedInc);

        game.current = { x: 0, y: prev.y - game_config.blockHeight, w: prev.w, h: game_config.blockHeight, hue: game.baseHue, dir: Math.random()<0.5?1:-1, speed: currentSpeed, isShining: isShining };
        
        game.current.x = game.current.dir === 1 ? -game.current.w : game.width;
    }

    function placeBlock() {
        if (game.state !== 'playing' && game.state !== 'demo') return;
        const curr = game.current; const prev = game.blocks[game.blocks.length-1];
        const dist = curr.x - prev.x; const absDist = Math.abs(dist);
        
        // --- 리플레이 데이터 기록 (정규화된 결과 기록으로 전환) ---
        
        let newX = curr.x; let newW = curr.w; let isShiningPerfect = false;

        if (absDist >= curr.w) {
            game.debris.push(createDebris(curr.x, curr.y, curr.w, curr.h, curr.hue));
            if (game.state === 'demo') { /* 데모 모드에서는 리셋을 막았으므로 여기는 미사용 */ } else { gameOver(); }
            // 게임 오버/실패 시에도 최종 결과(잘림) 기록
            newX = curr.x; // 실패 시의 블록 위치 (잘린 부분의 시작)
            newW = 0;      // 실패 시의 블록 너비 (0으로 기록)
            
        } else {
            // 성공/부분 성공 로직
            if (absDist <= game_config.perfectTol) {
                newX = prev.x; newW = prev.w; game.combo++;
                let growth = 0;
                if (curr.isShining) { growth = game_config.baseWidth - newW; newW = game_config.baseWidth; isShiningPerfect = true; }
                else if (newW < game_config.baseWidth) {
                    const potentialW = Math.min(newW + (game_config.baseWidth * game_config.recoveryRate), game_config.baseWidth);
                    growth = potentialW - newW; newW = potentialW;
                }
                if (growth > 0) {
                    const blockCenter = newX + prev.w / 2; const screenCenter = game.width / 2;
                    if (Math.abs(blockCenter - screenCenter) < 1) { newX -= growth / 2; } 
                    else if (blockCenter < screenCenter) { } else { newX -= growth; }
                }
                triggerPerfectEffect(newX, curr.y, newW, isShiningPerfect);
            } else {
                game.combo = 0; newW = curr.w - absDist;
                if (dist > 0) { newX = curr.x; game.debris.push(createDebris(curr.x + newW, curr.y, absDist, curr.h, curr.hue)); }
                else { newX = prev.x; game.debris.push(createDebris(curr.x, curr.y, absDist, curr.h, curr.hue)); }
                createEdgeBurst(newX, curr.y, newW, game_config.blockHeight, curr.hue);
            }

            // 블록을 스택에 추가
            game.blocks.push({ x: newX, y: curr.y, w: newW, h: game_config.blockHeight, hue: curr.hue });
            game.score++; ui.score.innerText = game.score; triggerScoreEffect();
            AudioSys.playStack(game.combo); 
            spawnBlock();
        }
        
        // --- 리플레이 데이터 기록: 최종 결과와 타이밍 기록 ---
        // curr.x (클릭 순간의 x좌표), newX (절단 후 최종 x좌표), newW (절단 후 최종 너비)
        game.replayData.push({ 
            time: performance.now() - game.replayStartTime, 
            x_norm: curr.x / game.width,        // 클릭 당시 x좌표 (정규화된 움직임 위치)
            w_norm: prev.w / game.width,        // 이전 블록의 너비 (정규화된 크기)
            curr_w_norm: curr.w / game.width,   // 현재 움직이는 블록의 크기 (잔해 생성용)
            newX_norm: newX / game.width,       // 최종 배치 x좌표 (정규화된 결과)
            newW_norm: newW / game.width,       // 최종 배치 너비 (정규화된 결과)
            
            hue: curr.hue, dir: curr.dir, speed: curr.speed, isShining: curr.isShining,
            canvasWidth: game.width, // 기록 당시 캔버스 너비 (참고용)
            failed: absDist >= curr.w // 실패 여부 플래그
        });
        
        if (absDist >= curr.w) { return; } // 게임 오버 후 placeBlock의 나머지 로직을 탈출
    }

    function triggerScoreEffect() {
        ui.score.classList.remove('score-pop'); void ui.score.offsetWidth; ui.score.classList.add('score-pop');
        const cx = game.width / 2; 
        const cy = game.height * 0.10; 
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 5 + 2;
            game.particles.push({ x: cx, y: cy, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 1.0, color: '#FFEA00', type: 'burst' });
        }
    }

    function updateDemo(dt) {
        const c = game.current; if (!c) return;
        c.x += c.speed * c.dir * dt;
        const prev = game.blocks[game.blocks.length - 1];
        let hit = (c.dir === 1 && c.x >= prev.x) || (c.dir === -1 && c.x <= prev.x);
        if (hit) { 
            c.x = prev.x; 
            // 데모 모드에서는 절단 로직을 실행하지 않고, 블록을 스택에 완벽하게 추가한 후 다음 블록을 바로 생성
            game.blocks.push({ x: c.x, y: c.y, w: c.w, h: c.h, hue: c.hue });
            game.score++; 
            AudioSys.playStack(game.combo); // 데모 플레이 시 음악 재생
            spawnBlock(); 
        } 
        else { if (c.x > game.width + 100 || c.x < -100 - c.w) c.dir *= -1; }
    }

    function createDebris(x, y, w, h, hue) {
        // 스케일링된 game_config 값 사용
        const scale = game.width / REF_WIDTH; // 너비 스케일
        const speedScale = game.width / REF_WIDTH; // 속도 스케일

        return { 
            x: x, y: y, w: w, h: h, hue: hue, 
            vx: (Math.random()-0.5) * (100 * speedScale), 
            vy: (Math.random()-0.5) * (100 * speedScale) - (67 * speedScale), 
            rot: 0, rotSpeed: (Math.random()-0.5) * game_config.debrisRot / (DEBRIS_ROT/20) * 10 
        };
    }

    function createEdgeBurst(x, y, w, h, hue) {
        const scale = game.width / REF_WIDTH;
        const speedScale = scale; // 속도 스케일

        const perimeter = (w + h) * 2; 
        const count = Math.min(40, Math.floor(perimeter / (6 * scale))); 
        for (let i = 0; i < count; i++) {
            const pos = Math.random() * perimeter; let px, py, vx, vy; 
            const speed = Math.random() * (67 * speedScale) + (33 * speedScale); 

            if (pos < w) { px = x + pos; py = y; vx = (Math.random() - 0.5) * speed; vy = -speed; } 
            else if (pos < w + h) { px = x + w; py = y + (pos - w); vx = speed; vy = (Math.random() - 0.5) * speed; } 
            else if (pos < w + h + w) { px = x + (pos - (w + h)); py = y + h; vx = (Math.random() - 0.5) * speed; vy = speed; } 
            else { px = x; py = y + (pos - (w + h + w)); vx = -speed; vy = (Math.random() - 0.5) * speed; }
            game.particles.push({ x: px, y: py, vx: vx, vy: vy, life: 1.0, color: `hsl(${hue}, 100%, 70%)` });
        }
    }

    function triggerPerfectEffect(x, y, w, isShiningPerfect) {
        if (game.state !== 'demo') {
            ui.combo.innerText = isShiningPerfect ? `SHINING x${game.combo}! (MAX)` : `PERFECT x${game.combo}`;
            ui.combo.style.textShadow = isShiningPerfect ? '0 0 25px #ff00ff, 0 0 50px #ff00ff' : '0 0 20px #0ff, 0 0 40px #0ff';
            ui.combo.style.opacity = '1'; ui.combo.style.transform = 'scale(1.2)';
            ui.score.style.color = '#fff'; ui.score.style.transform = 'scale(1.1)';
            setTimeout(() => { ui.combo.style.opacity = '0'; ui.combo.style.transform = 'scale(0.5)'; }, 500);
        }
        createEdgeBurst(x, y, w, game_config.blockHeight, game.current.hue);
        game.particles.push({ type: 'radial-wave', x: x+w/2, y: y+game_config.blockHeight/2, size: 0, max_size: w*1.5, life: 1.0, hue: game.current.hue });
    }

    function gameOver() {
        game.state = 'gameover';
        AudioSys.playFail();
        const score = game.score;
        const isHigh = highScores.length < MAX_RANKING_COUNT || score > highScores[highScores.length-1].score;
        setTimeout(() => {
            ui.title.innerText = "GAME OVER";
            ui.menu.classList.add('game-over-mode');
            ui.rankingBtn.classList.add('display-none'); 
            ui.rankingBoard.style.display = 'block'; 
            ui.btn.innerText = "RETRY";
            // 게임 오버 시 버튼 표시
            ui.bottomControls.style.display = 'flex';
            ui.menu.classList.remove('hide');
            if(isHigh && score > 0) { promptForInitials(score); }
            else displayHighScores();
        }, 800);
    }

    // =========================================================================
    // REPLAY LOGIC
    // =========================================================================

    function startReplay(data) {
        if(!data || !data.length) return;
        game.state = 'replay';
        game.replayQueue = data;
        game.replayIndex = 0;
        game.blocks = []; game.debris = []; game.particles = []; game.score = 0; game.cameraY = 0;
        ui.score.innerText = "0";
        ui.menu.classList.add('hide');
        ui.rankingBoard.style.display = 'none'; 
        ui.replayIndicator.classList.remove('display-none');
        ui.closeReplayBtn.classList.remove('display-none');
        // --- 수정: 리플레이 시 랭킹 버튼 숨기기 ---
        ui.rankingBtn.classList.add('display-none');

        const startX = (game.width - game_config.baseWidth) / 2;
        
        // 리플레이 시작 시 초기 블록 위치 조정
        const startY = game.height * 0.90;

        game.blocks.push({ x: startX, y: startY, w: game_config.baseWidth, h: game_config.blockHeight, hue: game.replayQueue[0].hue - 10 });
        
        game.replayStartTime = performance.now();
        game.replayCurrentTime = 0;
        
        // 리플레이는 첫 번째 블록 (Base) 다음부터 시작합니다.
        game.replayIndex = 0; // placeBlock이 모든 스텝을 기록하므로 0부터 시작하고, 첫 번째 스텝을 바로 처리합니다.
        prepareReplayStep();
    }
    
    function stopReplay() { initGame(true); }

    function prepareReplayStep() {
        if(game.replayIndex >= game.replayQueue.length) {
            setTimeout(stopReplay, 1000); 
            return;
        }
        const d = game.replayQueue[game.replayIndex];
        const prev = game.blocks[game.blocks.length-1];

        // --- 리플레이 데이터 스케일링 (정규화된 값을 현재 캔버스 너비에 맞게 조정) ---
        // 기록된 canvasWidth가 없거나 0이면 현재 game.width를 사용 (오차 발생 가능성 감수)
        const recordedWidth = d.canvasWidth || REF_WIDTH;
        const scaling_ratio = game.width / recordedWidth; 
        
        // 이동 블록의 목표 x 좌표 및 크기 (클릭 순간의 상태)
        const targetX_scaled = d.x_norm * game.width; 
        const w_scaled = d.w_norm * game.width; 
        const curr_w_scaled = d.curr_w_norm * game.width; // 현재 움직이는 블록의 크기
        
        game.current = { 
            x: d.dir===1 ? -curr_w_scaled : game.width, // 시작 위치는 curr_w_scaled 사용
            targetX: targetX_scaled, // 클릭 당시의 X 위치
            targetW: d.newW_norm * game.width, // 최종 배치될 너비
            targetNewX: d.newX_norm * game.width, // 최종 배치될 X 위치
            failed: d.failed,
            
            y: prev.y - game_config.blockHeight, 
            w: curr_w_scaled, // 움직이는 블록의 크기는 curr_w_scaled 사용
            h: game_config.blockHeight, 
            hue: d.hue, 
            dir: d.dir, 
            speed: d.speed,
            isShining: d.isShining,
            targetTime: d.time || 0,
            distance: 0,
            expectedDuration: 0
        };
    }
    
    function updateReplay(dt) {
        const c = game.current; 
        if (!c) return;

        game.replayCurrentTime += dt * 1000;

        if (game.replayCurrentTime >= c.targetTime) {
            
            const prev = game.blocks[game.blocks.length-1];

            // 1. 실패 시 처리 (단순히 잔해를 만들고 다음 스텝으로)
            if (c.failed) {
                // c.x는 현재 이동 중인 위치이므로, 잔해를 만들 위치를 목표 x로 설정합니다.
                const failedX = c.targetX; 
                game.debris.push(createDebris(failedX, c.y, c.w, c.h, c.hue)); // c.w는 움직이는 블록의 크기
                AudioSys.playFail(); 
                
                // 리플레이 종료 (다음 스텝이 없으므로 prepareReplayStep이 종료 처리)
                game.current = null;
                game.replayIndex++; 
                prepareReplayStep();
                return;
            }

            // 2. 성공/부분 성공 시 처리 (기록된 결과를 적용)
            
            // 최종 결과는 기록된 targetNewX와 targetW를 사용합니다.
            const newX = c.targetNewX;
            const newW = c.targetW;
            
            // 시각적 효과를 위한 오차 계산 (잔해 및 파티클 생성)
            const cutW = c.w - newW; // 잘려나간 너비 (움직이는 블록 크기 - 최종 블록 크기)

            // 오차 여부 확인 (잔해/퍼펙트 효과 발생 기준)
            const dist = c.targetX - prev.x; 
            const absDist = Math.abs(dist);

            if (absDist <= game_config.perfectTol) {
                game.combo++; 
                triggerPerfectEffect(newX, c.y, newW, c.isShining);
            } else {
                game.combo = 0; 
                
                if (dist > 0) { 
                    // 오른쪽 잘림: 잔해는 새로운 블록의 오른쪽 경계에서 시작
                    game.debris.push(createDebris(newX + newW, c.y, cutW, c.h, c.hue));
                } else { 
                    // 왼쪽 잘림: 잔해는 새로운 블록의 왼쪽 경계에서 시작 
                    game.debris.push(createDebris(newX - cutW, c.y, cutW, c.h, c.hue));
                }
                createEdgeBurst(newX, c.y, newW, game_config.blockHeight, c.hue);
            }

            // 블록 스택 업데이트 (기록된 정확한 결과 적용)
            game.blocks.push({ x: newX, y: c.y, w: newW, h: game_config.blockHeight, hue: c.hue });
            game.score++; ui.score.innerText = game.score; triggerScoreEffect(); 
            AudioSys.playStack(game.combo); 
            
            // 다음 스텝 준비
            game.current = null; 
            game.replayIndex++; 
            prepareReplayStep();
            
        } else {
            // 시간 경과에 따른 블록 이동을 부드럽게 시뮬레이션
            const prevTime = game.replayIndex > 0 ? game.replayQueue[game.replayIndex - 1].time : 0;
            const elapsed = game.replayCurrentTime - prevTime;
            const duration = c.targetTime - prevTime;
            
            let progress;
            if (duration > 0) {
                progress = Math.min(1, elapsed / duration);
            } else {
                progress = 1;
            }

            // 리플레이 블록 이동 처리: 시작 위치와 목표 위치 사이를 progress에 따라 이동
            const startX = c.dir===1 ? -c.w : game.width;
            c.x = startX + (c.targetX - startX) * progress;
        }
    }

    // =========================================================================
    // DRAWING LOOP
    // =========================================================================

    function getGradient(ctx, x, y, w, h, hue) {
        const grad = ctx.createLinearGradient(x, y, x + w, y + h);
        const time = Date.now() * 0.002; const shift = (Math.sin(time + y * 0.01) + 1) / 2;
        grad.addColorStop(0, `hsl(${hue}, 100%, 50%)`); grad.addColorStop(shift, `hsl(${hue}, 100%, 75%)`); grad.addColorStop(1, `hsl(${hue}, 100%, 50%)`);
        return grad;
    }

    function loop(timestamp) {
        requestAnimationFrame(loop);
        
        // Calculate DT (in seconds)
        if (!lastTime) lastTime = timestamp;
        let dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        
        if (dt > 0.1) dt = 0.1;

        // --- 1. 배경 그리기 ---
        ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, game.width, game.height);
        ctx.fillStyle = '#fff';
        for(let s of game.stars) {
            s.y += s.speed * dt; if(s.y > game.height) { s.y=0; s.x=Math.random()*game.width; }
            ctx.globalAlpha = Math.max(0.1, Math.min(1, s.opacity + Math.sin(Date.now()*s.twinkleSpeed)*0.3));
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size/2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
        }

        // --- 2. 카메라 위치 업데이트 ---
        if(game.blocks.length > 0) {
            // 카메라 목표 위치를 캔버스 높이의 25% 지점으로 설정
            const camera_target_y_percent = 0.25; 
            
            // 캔버스 높이의 25% 지점 픽셀 값
            const camera_target_y_pos = game.height * camera_target_y_percent; 
            
            // 다음 블록이 놓일 캔버스 기준 Y 좌표
            const prevBlockY = game.blocks[game.blocks.length - 1].y;
            const nextBlockY = prevBlockY - game_config.blockHeight; 
            
            // 다음 블록이 놓일 위치 (nextBlockY)를 화면 상단 camera_target_y_pos에 보이게 하려면, 
            // 카메라 Y를 (nextBlockY - camera_target_y_pos) 만큼 이동시켜야 함.
            const ty = nextBlockY - camera_target_y_pos;

            // Camera lerp (approx exponential decay)
            // Math.max(0, ty)를 사용하여 카메라가 시작 지점(0) 이하로 내려가지 않도록 함
            game.cameraY += (Math.max(0, -ty) - game.cameraY) * 5.0 * dt; 
        }

        // --- 3. 스택 블록 그리기 ---
        for(let b of game.blocks) {
            const dy = b.y+game.cameraY; if(dy>game.height) continue;
            ctx.shadowBlur=15; ctx.shadowColor=`hsl(${b.hue},100%,50%)`; 
            ctx.fillStyle = getGradient(ctx, b.x, dy, b.w, b.h, b.hue);
            ctx.fillRect(b.x, dy, b.w, b.h);
            ctx.shadowBlur=0; ctx.fillStyle=`hsla(${b.hue},100%,80%,0.6)`; ctx.fillRect(b.x, dy, b.w, 4);
        }

        // --- 4. 현재 움직이는 블록 업데이트 및 그리기 ---
        if(game.current) {
            if(game.state==='demo') updateDemo(dt);
            else if(game.state==='playing') {
                game.current.x += game.current.speed * game.current.dir * dt;
                // 블록이 캔버스 경계를 넘어갔을 때 방향 전환
                const max_x = game.width - game.current.w;
                const min_x = 0;
                
                if (game.current.dir === 1 && game.current.x >= max_x) {
                    game.current.dir = -1;
                    game.current.x = max_x; // 경계에 고정
                } else if (game.current.dir === -1 && game.current.x <= min_x) {
                    game.current.dir = 1;
                    game.current.x = min_x; // 경계에 고정
                }
            } else if(game.state==='replay') updateReplay(dt);
            
            if((game.state==='playing'||game.state==='demo'||game.state==='replay') && game.current) {
                const c = game.current; const dy = c.y+game.cameraY;
                let hue = c.hue, glow = 20;
                if(c.isShining) { hue = (c.hue+Math.floor(Date.now()/30))%360; glow=40; }
                ctx.shadowBlur=glow; ctx.shadowColor=`hsl(${hue},100%,50%)`; 
                ctx.fillStyle = getGradient(ctx, c.x, dy, c.w, c.h, hue);
                ctx.fillRect(c.x, dy, c.w, c.h);
                ctx.shadowBlur=0; ctx.fillStyle=`rgba(255,255,255,0.8)`; ctx.fillRect(c.x, dy, c.w, 4);
            }
        }

        // --- 5. 파편(Debris) 및 파티클 그리기 ---
        for(let i=game.debris.length-1; i>=0; i--) {
            let d = game.debris[i]; 
            d.x += d.vx * dt; 
            d.y += d.vy * dt; 
            d.vy += game_config.gravity * dt; 
            d.rot += d.rotSpeed * dt;
            ctx.save(); ctx.translate(d.x+d.w/2, d.y+game.cameraY+d.h/2); ctx.rotate(d.rot);
            ctx.fillStyle=`hsla(${d.hue},100%,50%,0.5)`; ctx.fillRect(-d.w/2, -d.h/2, d.w, d.h); ctx.restore();
            if(d.y+game.cameraY > game.height) game.debris.splice(i,1);
        }
        for(let i=game.particles.length-1; i>=0; i--) {
            let p=game.particles[i]; 
            p.life -= game_config.particleDecay * dt;
            if(p.life<=0) { game.particles.splice(i,1); continue; }
            
            if(p.type==='radial-wave') {
                ctx.strokeStyle=`hsla(${p.hue},100%,80%,${p.life})`; 
                ctx.lineWidth=3 * (game.width / REF_WIDTH); // 굵기 스케일링
                p.size += (p.max_size - p.size) * 5.0 * dt;
                ctx.beginPath(); ctx.arc(p.x, p.y+game.cameraY, p.size, 0, Math.PI*2); ctx.stroke();
            } else {
                p.x += p.vx * dt; 
                p.y += p.vy * dt; 
                ctx.fillStyle=p.color; ctx.globalAlpha=p.life;
                
                const particleSize = 3 * (game.width / REF_WIDTH); // 파티클 크기 스케일링
                if(p.type==='burst' && p.color === '#FFEA00') { ctx.beginPath(); ctx.arc(p.x, p.y, 2 * (game.width / REF_WIDTH), 0, Math.PI*2); ctx.fill(); } 
                else { ctx.beginPath(); ctx.arc(p.x, p.y+game.cameraY, particleSize, 0, Math.PI*2); ctx.fill(); }
                ctx.globalAlpha=1;
            }
        }
    }

    // =========================================================================
    // EVENT LISTENERS & ENTRY POINT
    // =========================================================================
    window.addEventListener('resize', resize);

    // 초기 설정
    resize();
    loop(0);

    ui.intro.onclick = () => {
        AudioSys.init(); 
        ui.intro.style.opacity = '0';
        setTimeout(() => ui.intro.classList.add('hide'), 500);
        initGame(true); 
    };

    // --- 수정된 리트라이 로직: 게임 오버/데모 상태일 때만 startGame 호출 ---
    ui.btn.onclick = (e) => { 
        e.stopPropagation(); 
        if (game.state === 'demo' || game.state === 'gameover') {
            startGame(); 
        }
    };
    
    ui.closeReplayBtn.onclick = (e) => { e.stopPropagation(); stopReplay(); };
    
    // Toggle Ranking Board
    ui.rankingBtn.onclick = (e) => {
        e.stopPropagation();
        if(ui.rankingBoard.style.display === 'block') {
            ui.rankingBoard.style.display = 'none';
        } else {
            ui.rankingBoard.style.display = 'block';
            displayHighScores();
        }
    };
    ui.closeRankingBtn.onclick = (e) => {
        e.stopPropagation();
        ui.rankingBoard.style.display = 'none';
    };
    
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault(); 
            
            // 인트로 화면 -> 데모 시작
            if (!ui.intro.classList.contains('hide')) { ui.intro.click(); return; }
            
            // 메뉴(데모/게임 오버) 화면일 때만 START/RETRY 허용
            if (game.state === 'demo' || game.state === 'gameover') {
                 if (!ui.menu.classList.contains('hide') && !document.getElementById('initialsModal')) { 
                    startGame(); return; 
                 }
            }
            
            // 플레이 중일 때 블록 배치
            if (game.state === 'playing') { placeBlock(); }
        }
        if (e.code === 'Escape') {
            if (game.state === 'replay') stopReplay();
            else if (ui.rankingBoard.style.display === 'block') ui.rankingBoard.style.display = 'none';
        }
    });

    const handleInput = (e) => {
        if(e.target===ui.btn || e.target===ui.closeReplayBtn || e.target===ui.rankingBtn || e.target===ui.closeRankingBtn || 
           e.target.closest('#ranking-board') || e.target.tagName==='INPUT' || e.target.id==='submitInitials' || e.target.id==='intro-screen') return;
        
        // 메뉴 화면(데모/게임 오버)이 표시 중일 때, 버튼이 아닌 캔버스 영역 클릭은 무시
        if (!ui.menu.classList.contains('hide')) {
             return;
        }

        // 'playing' 상태일 때만 블록 배치 허용
        if(game.state==='playing') { 
            e.preventDefault(); 
            placeBlock(); 
        }
    };
    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, {passive:false});
    
</script>
</body>
</html>